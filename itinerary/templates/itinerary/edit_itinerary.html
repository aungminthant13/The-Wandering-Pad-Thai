{% extends "itinerary/base.html" %}
{% block title %}Edit Itinerary{% endblock %}

{% block content %}

{% block css %} 
<link rel="stylesheet" href="/static/itinerary/css/edit_itinerary_styles.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css"> 
{% endblock %}

<!-- navbar -->
<nav class="navbar">
    <div class="logo">
      <a href="{% url 'home' %}"
        ><span class="logo-text">The Wandering Pad Thai</span></a
      >
    </div>
    
    <div class="user-acc">
        <a href="{% url 'itinerary:save_itinerary' itinerary.id %}" class="user-acc-button">Next →</a>
        
    </div>
</nav>

<section>
    <!-- trip details -->
     <div class="trip_details">
        <div class="trip_info">
            <div class="trip_title">
                {{ itinerary.title }}
                <span id="saveStatus" class="save-status">All changes saved!</span>
             </div>
             <div class="trip_dates">
                <div>{{ itinerary.start_date|date:"D, F j, Y" }} · · · ➡️ · · · {{ itinerary.return_date|date:"D, F j, Y" }}</div>
             </div>
        </div>

        <!-- View toggle switch -->
        <div class="view-toggle-container">
            <div class="view-toggle">
            <input type="checkbox" id="viewToggle" class="toggle-checkbox">
            <label for="viewToggle" class="toggle-label">
                <span class="toggle-text-left">Board</span>
                <span class="toggle-text-right">Map</span>
                <span class="toggle-slider"></span>
            </label>
        </div>
    </div>
     </div>
</section>


<!-- itinerary board -->
<section id="boardView">
    <div class="itinerary_board">
        {% for date in date_list %}
        <div class="itinerary_column" data-date="{{ date|date:'Y-m-d' }}">
            <div class="itinerary_column_dateNo">{{ forloop.counter }}</div>
            <div class="itinerary_column_date">{{ date|date:"D, F j, Y" }}</div>
    
            <button class="itinerary_column_add_placeCard">Add A Place</button>
    
            <!-- This is where new cards will be injected -->
            <div class="place_cards_container">
                {% for card in place_cards %}
                    {% if card.date|date:'Y-m-d' == date|date:'Y-m-d' %}
                    <div class="place_card" 
                         draggable="true" 
                         data-card-id="{{ card.id }}"
                         data-place-id="{{ card.google_place_id }}"
                         data-place-lat="{{ card.latitude }}"
                         data-place-lng="{{ card.longitude }}"
                         data-place-address="{{ card.address }}"
                         data-original-place-name="{{ card.google_place_name }}"
                         data-start-time="{% if card.start_time %}{{ card.start_time|time:'H:i' }}{% endif %}"
                         data-end-time="{% if card.end_time %}{{ card.end_time|time:'H:i' }}{% endif %}">
                        
                        <div class="drag-handle">⋮⋮</div>
                        <strong>{{ card.title }}</strong><br>
                        
                        {% if card.start_time or card.end_time %}
                            <span class="time-span">
                                {% if card.start_time and card.end_time %}
                                    {{ card.start_time|time:"H:i" }} - {{ card.end_time|time:"H:i" }}
                                {% elif card.start_time %}
                                    {{ card.start_time|time:"H:i" }}
                                {% elif card.end_time %}
                                    Until {{ card.end_time|time:"H:i" }}
                                {% endif %}
                            </span><br>
                        {% endif %}
                        
                        {% if card.notes %}
                            <p>{{ card.notes }}</p>
                        {% endif %}
                    </div>
                    {% endif %}
                {% endfor %}
            </div>
        </div>
        {% endfor %}
    </div>
</section>

<!-- Map view -->
<section id="mapView" style="display: none;">
    <div class="map-container">
        <div id="itineraryMap" class="itinerary-map"></div>
    </div>
</section>

<!-- MODAL -->
<div id="placeCardFormModal" class="placeCardFormModal hidden">
    <form id="placeCardForm">
        <button type="button" id="deleteFormBtn" style="background-color: #ffffff; color: white; display: none; margin-top: -5px; left: -3px;"><i class="fa fa-trash-o" style="font-size:20px;color:red"></i></button>
        <h3 style="margin-bottom: 20px; text-align: center;">Add New Place</h3>
        
        <!-- Place search input with autocomplete -->
        <div class="place-search-container">
            <input type="text" id="placeSearchInput" placeholder="Search for a place..." autocomplete="off">
            <div id="placeSearchResults" class="place-search-results hidden"></div>
        </div>
        
        <input type="text" name="title" placeholder="Place Name" required>
        <div class="time-inputs">
            <div class="time-input-group">
                <label for="start_time">Start at</label>
                <input type="time" name="time" id="start_time">
            </div>
            <div class="time-input-group">
                <label for="end_time">Until</label>
                <input type="time" name="end_time" id="end_time">
            </div>
        </div>
        <textarea name="notes" placeholder="Notes" rows="3"></textarea>

        <input type="hidden" name="date" id="placeFormDate">
        <!-- Hidden fields to store place data -->
        <input type="hidden" name="place_id" id="placeId">
        <input type="hidden" name="place_lat" id="placeLat">
        <input type="hidden" name="place_lng" id="placeLng">
        <input type="hidden" name="place_address" id="placeAddress">
        <input type="hidden" name="card_id" id="cardId">

        <div style="text-align: center;">
            <button type="button" id="cancelFormBtn">✕</button>
            <button type="submit">Save Place</button>
        </div>
    </form>
</div>

<!-- Load Google Maps JavaScript API -->
<script>
    // Global variables
    const ITINERARY_ID = "{{ itinerary.id }}";
    let map = null;
    let markers = [];
    let infoWindows = [];
    
    // Load Google Maps API with Places library
    function loadGoogleMapsAPI() {
        const script = document.createElement('script');
        script.src = `https://maps.googleapis.com/maps/api/js?key=AIzaSyDAUVXGHCpvYCMOEYYAwJrxT-YDIBmzffg&libraries=places&callback=initializePlaces`;
        script.async = true;
        script.defer = true;
        document.head.appendChild(script);
    }

    // Initialize Places service after API loads
    function initializePlaces() {
        window.placesService = new google.maps.places.PlacesService(document.createElement('div'));
        window.autocompleteService = new google.maps.places.AutocompleteService();
        
        // Set a flag that API is loaded
        window.googleMapsLoaded = true;
        
        // Initialize map if toggle is already checked
        const viewToggle = document.getElementById('viewToggle');
        if (viewToggle && viewToggle.checked) {
            initializeMap();
        }
    }

    // Initialize the map
    function initializeMap() {
        console.log('Initializing map...');
        const mapElement = document.getElementById('itineraryMap');
        if (!mapElement) {
            console.error('Map element not found!');
            return;
        }

        try {
            map = new google.maps.Map(mapElement, {
                center: { lat: 13.7563, lng: 100.5018 }, //BKK
                zoom: 12,
                styles: [
                    {
                        featureType: "poi",
                        elementType: "labels",
                        stylers: [{ visibility: "off" }]
                    }
                ]
            });
            
            console.log('Map created successfully');

            // Add places to map
            updateMapMarkers();
        } catch (error) {
            console.error('Error creating map:', error);
        }
    }

    // Update map markers based on current place cards
    function updateMapMarkers() {
        console.log('Updating map markers...');
        if (!map) {
            console.error('Map not initialized!');
            return;
        }

        // Clear existing markers
        markers.forEach(marker => marker.setMap(null));
        markers = [];
        infoWindows.forEach(infoWindow => infoWindow.close());
        infoWindows = [];

        const bounds = new google.maps.LatLngBounds();
        let hasValidMarkers = false;

        // Collect all place cards with their date numbers
        document.querySelectorAll('.itinerary_column').forEach((column, index) => {
            const dateNumber = index + 1;
            const cards = column.querySelectorAll('.place_card');

            cards.forEach((card, cardIndex) => {
                const placeName = document.getElementById('placeSearchInput').value;
                const lat = parseFloat(card.dataset.placeLat);
                const lng = parseFloat(card.dataset.placeLng);
                const title = card.querySelector('strong').textContent;
                const timeSpan = card.querySelector('.time-span');
                const notes = card.querySelector('p');

                // Skip if no valid coordinates
                if (!lat || !lng || isNaN(lat) || isNaN(lng)) return;

                hasValidMarkers = true;
                const position = { lat, lng };

                // Create custom marker with date number
                const marker = new google.maps.Marker({
                    position: position,
                    map: map,
                    title: title,
                    label: {
                        text: `${dateNumber}`,
                        color: 'black',
                        fontSize: '14px',
                        fontWeight: 'bold'
                    },
                    icon: {
                        path: google.maps.SymbolPath.CIRCLE,
                        fillColor: getColorForDate(dateNumber),
                        fillOpacity: 1,
                        strokeColor: 'black',
                        strokeWeight: 2,
                        scale: 15
                    }
                });


                // Create info window content
                let infoContent = `
                    <div class="map-info-window">
                        <h3>${placeName}</h2>
                        <h4>Day ${dateNumber}: ${title}</h4>
                `;

                if (timeSpan) {
                    infoContent += `<p class="time-info">${timeSpan.textContent}</p>`;
                }

                if (notes) {
                    infoContent += `<p class="notes-info">${notes.textContent}</p>`;
                }

                if (card.dataset.placeAddress) {
                    infoContent += `<p class="address-info">${card.dataset.placeAddress}</p>`;
                }

                infoContent += '</div>';

                const infoWindow = new google.maps.InfoWindow({
                    content: infoContent
                });

                marker.addListener('click', () => {
                    // Close all other info windows
                    infoWindows.forEach(iw => iw.close());
                    infoWindow.open(map, marker);
                });

                markers.push(marker);
                infoWindows.push(infoWindow);
                bounds.extend(position);
            });
        });

        // Fit map to show all markers
        if (hasValidMarkers) {
            map.fitBounds(bounds);
            
            // Don't zoom in too much for single markers
            const listener = google.maps.event.addListener(map, "idle", function() {
                if (map.getZoom() > 16) map.setZoom(16);
                google.maps.event.removeListener(listener);
            });
        }
    }

    // Get color for date marker
    function getColorForDate(dateNumber) {
        const colors = [
            '#4ECDC4',
            '#FFEAA7',
            '#FF6B6B',
            '#BB8FCE',
            '#45B7D1', 
            '#98D8C8',
            '#FFA07A',
            '#d35ce0',
            '#96CEB4',
            '#F7DC6F',
        ];
        return colors[(dateNumber - 1) % colors.length];
    }

    // Load the API when page loads
    loadGoogleMapsAPI();
</script>

<script>
    // Wait for DOM to be fully loaded
    document.addEventListener('DOMContentLoaded', function() {
        console.log('DOM loaded, initializing modal functionality');
        
        // VIEW TOGGLE FUNCTIONALITY
        const viewToggle = document.getElementById('viewToggle');
        const boardView = document.getElementById('boardView');
        const mapView = document.getElementById('mapView');

        viewToggle.addEventListener('change', function() {
            if (this.checked) {
                // Show map view
                boardView.style.display = 'none';
                mapView.style.display = 'block';
                
                // Check if Google Maps is loaded
                if (!window.googleMapsLoaded) {
                    console.log('Waiting for Google Maps to load...');
                    // Try again in a moment
                    const checkInterval = setInterval(() => {
                        if (window.googleMapsLoaded) {
                            clearInterval(checkInterval);
                            initializeMap();
                        }
                    }, 100);
                } else if (!map) {
                    // Initialize map if not already done
                    initializeMap();
                } else {
                    // Update markers and trigger resize
                    setTimeout(() => {
                        google.maps.event.trigger(map, 'resize');
                        updateMapMarkers();
                    }, 100);
                }
            } else {
                // Show board view
                boardView.style.display = 'block';
                mapView.style.display = 'none';
            }
        });
        
        // SAVE STATUS MANAGEMENT
        const saveStatus = document.getElementById('saveStatus');
        let saveTimeout;

        function showSaveStatus(status, message) {
            clearTimeout(saveTimeout);
            
            saveStatus.className = `save-status ${status}`;
            saveStatus.textContent = message;
            
            if (status === 'saving') {
                return;
            }
            
            if (status === 'saved') {
                saveTimeout = setTimeout(() => {
                    saveStatus.className = 'save-status';
                    saveStatus.textContent = 'All changes saved!';
                }, 2000);
            } else if (status === 'error') {
                saveTimeout = setTimeout(() => {
                    saveStatus.className = 'save-status';
                    saveStatus.textContent = 'All changes saved!';
                }, 5000);
            }
        }

        // AUTO-SAVE FUNCTIONS
        async function autoSaveCard(cardData) {
            showSaveStatus('saving', 'Saving...');
            
            try {
                console.log('Saving card data:', cardData);
                
                const response = await fetch(`/itinerary/${ITINERARY_ID}/place-cards/save/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCsrfToken()
                    },
                    body: JSON.stringify(cardData)
                });
                
                const result = await response.json();
                console.log('Save response:', result);
                
                if (result.success) {
                    showSaveStatus('saved', 'Saved!');
                    
                    // Update map markers if in map view
                    if (viewToggle.checked) {
                        setTimeout(updateMapMarkers, 100);
                    }
                    
                    return result.card_id;
                } else {
                    showSaveStatus('error', 'Save failed');
                    console.error('Save error:', result.message);
                    alert('Save failed: ' + result.message);
                    return null;
                }
            } catch (error) {
                showSaveStatus('error', 'Save failed');
                console.error('Network error:', error);
                alert('Network error: ' + error.message);
                return null;
            }
        }

        function getCsrfToken() {
            return document.querySelector('[name=csrfmiddlewaretoken]')?.value || 
                   document.querySelector('meta[name="csrf-token"]')?.content || '';
        }

        // Get DOM elements
        const modal = document.getElementById('placeCardFormModal');
        const form = document.getElementById('placeCardForm');
        const cancelBtn = document.getElementById('cancelFormBtn');
        const deleteBtn = document.getElementById('deleteFormBtn');
        const placeFormDate = document.getElementById('placeFormDate');
        const cardIdInput = document.getElementById('cardId');
        
        // Place search elements
        const placeSearchInput = document.getElementById('placeSearchInput');
        const placeSearchResults = document.getElementById('placeSearchResults');
        const placeNameInput = form.title;
        const placeIdInput = document.getElementById('placeId');
        const placeLatInput = document.getElementById('placeLat');
        const placeLngInput = document.getElementById('placeLng');
        const placeAddressInput = document.getElementById('placeAddress');
        
        let editingCard = null;

        // Check if essential elements exist
        console.log('Modal:', modal);
        console.log('Form:', form);
        
        if (!modal || !form) {
            console.error('Essential elements not found!');
            return;
        }

        // Function to clear Google Places data
        function clearGooglePlacesData() {
            console.log('Clearing Google Places data');
            placeIdInput.value = '';
            placeLatInput.value = '';
            placeLngInput.value = '';
            placeAddressInput.value = '';
            placeSearchInput.value = '';
            placeSearchResults.classList.add('hidden');
        }

        // Show modal for adding new place
        console.log('Setting up add place button listeners');
        document.querySelectorAll('.itinerary_column_add_placeCard').forEach((btn, index) => {
            console.log(`Setting up listener for button ${index}`);
            
            btn.addEventListener('click', function(e) {
                console.log('Add place button clicked!');
                e.preventDefault();
                
                const column = btn.closest('.itinerary_column');
                const date = column.dataset.date;
                console.log('Date:', date);

                // Reset form and state
                editingCard = null;
                form.reset();
                cardIdInput.value = '';
                clearGooglePlacesData();
                
                placeFormDate.value = date;

                // Update modal content for adding
                document.querySelector('#placeCardForm h3').textContent = 'Add New Place';
                document.querySelector('#placeCardForm button[type="submit"]').textContent = 'Save Place';
                deleteBtn.style.display = 'none';

                // Show modal
                console.log('Showing modal...');
                modal.classList.remove('hidden');
                console.log('Modal classes:', modal.className);
            });
        });

        // Cancel button
        cancelBtn.addEventListener('click', function() {
            console.log('Cancel button clicked');
            form.reset();
            clearGooglePlacesData();
            editingCard = null;
            modal.classList.add('hidden');
        });

        // Close when clicking outside the form
        modal.addEventListener('click', function(event) {
            if (!form.contains(event.target)) {
                console.log('Clicked outside form, closing modal');
                form.reset();
                clearGooglePlacesData();
                editingCard = null;
                modal.classList.add('hidden');
            }
        });

        // Form submission
        form.addEventListener('submit', async function(e) {
            e.preventDefault();
            console.log('Form submitted');

            // Calculate order for new cards
            let order = 0;
            if (!editingCard) {
                const targetColumn = document.querySelector(`.itinerary_column[data-date="${this.date.value}"]`);
                const existingCards = targetColumn.querySelectorAll('.place_card');
                order = existingCards.length;
            }

            const cardData = {
                card_id: cardIdInput.value || '',
                title: this.title.value || '',
                start_time: this.time.value || '',
                end_time: this.end_time.value || '',
                notes: this.notes.value || '',
                date: this.date.value,
                place_id: placeIdInput.value || '',
                place_lat: placeLatInput.value || '',
                place_lng: placeLngInput.value || '',
                place_address: placeAddressInput.value || '',
                original_place_name: placeSearchInput.value || this.title.value || '',
                order: order
            };

            console.log('Card data to save:', cardData);

            const savedCardId = await autoSaveCard(cardData);
            
            if (!savedCardId) {
                console.error('Save failed, not updating UI');
                return;
            }

            // Create/Update the card in UI
            if (editingCard) {
                // UPDATE EXISTING CARD
                let cardHTML = `
                    <div class="drag-handle">⋮⋮</div>
                    <strong>${cardData.title}</strong><br>`;
                
                let timeDisplay = '';
                if (cardData.start_time && cardData.end_time) {
                    timeDisplay = `${cardData.start_time} - ${cardData.end_time}`;
                } else if (cardData.start_time) {
                    timeDisplay = `${cardData.start_time}`;
                } else if (cardData.end_time) {
                    timeDisplay = `Until ${cardData.end_time}`;
                }
                
                if (timeDisplay) {
                    cardHTML += `<span class="time-span">${timeDisplay}</span><br>`;
                }
                
                if (cardData.notes) {
                    cardHTML += `<p>${cardData.notes}</p>`;
                }
                
                editingCard.innerHTML = cardHTML;

                // Update data attributes
                editingCard.dataset.cardId = savedCardId;
                editingCard.dataset.placeId = cardData.place_id || '';
                editingCard.dataset.placeLat = cardData.place_lat || '';
                editingCard.dataset.placeLng = cardData.place_lng || '';
                editingCard.dataset.placeAddress = cardData.place_address || '';
                editingCard.dataset.originalPlaceName = cardData.original_place_name || '';
                editingCard.dataset.startTime = cardData.start_time || '';
                editingCard.dataset.endTime = cardData.end_time || '';

                // Move card if date changed
                const currentColumn = editingCard.closest('.itinerary_column');
                const currentDate = currentColumn.dataset.date;
                
                if (currentDate !== cardData.date) {
                    const newColumn = document.querySelector(`.itinerary_column[data-date="${cardData.date}"]`);
                    const newContainer = newColumn.querySelector('.place_cards_container');
                    newContainer.appendChild(editingCard);
                }

                editingCard = null;
            } else {
                // CREATE NEW CARD
                const column = document.querySelector(`.itinerary_column[data-date="${cardData.date}"]`);
                const container = column.querySelector('.place_cards_container');

                const card = document.createElement('div');
                card.classList.add('place_card');
                card.draggable = true;
                
                // Store all data attributes
                card.dataset.cardId = savedCardId;
                card.dataset.placeId = cardData.place_id || '';
                card.dataset.placeLat = cardData.place_lat || '';
                card.dataset.placeLng = cardData.place_lng || '';
                card.dataset.placeAddress = cardData.place_address || '';
                card.dataset.originalPlaceName = cardData.original_place_name || '';
                card.dataset.startTime = cardData.start_time || '';
                card.dataset.endTime = cardData.end_time || '';
                
                let cardHTML = `<div class="drag-handle">⋮⋮</div><strong>${cardData.title}</strong><br>`;
                
                let timeDisplay = '';
                if (cardData.start_time && cardData.end_time) {
                    timeDisplay = `${cardData.start_time} - ${cardData.end_time}`;
                } else if (cardData.start_time) {
                    timeDisplay = `${cardData.start_time}`;
                } else if (cardData.end_time) {
                    timeDisplay = `Until ${cardData.end_time}`;
                }
                
                if (timeDisplay) {
                    cardHTML += `<span class="time-span">${timeDisplay}</span><br>`;
                }
                
                if (cardData.notes) {
                    cardHTML += `<p>${cardData.notes}</p>`;
                }
                
                card.innerHTML = cardHTML;

                // Add drag and edit listeners to new card
                addDragListeners(card);
                addEditListener(card);

                container.appendChild(card);
            }

            // Reset and hide form
            this.reset();
            clearGooglePlacesData();
            modal.classList.add('hidden');
        });

        console.log('Modal setup complete');

        // GOOGLE PLACES SEARCH FUNCTIONALITY
        let searchTimeout;
        
        placeSearchInput.addEventListener('input', function() {
            clearTimeout(searchTimeout);
            const query = this.value.trim();
            
            if (query.length < 2) {
                placeSearchResults.classList.add('hidden');
                return;
            }

            searchTimeout = setTimeout(() => {
                searchPlaces(query);
            }, 300);
        });

        function searchPlaces(query) {
            if (!window.autocompleteService) {
                console.error('Google Places API not loaded yet');
                return;
            }

            const request = {
                input: query,
                location: new google.maps.LatLng(13.7563, 100.5018),
                radius: 30000,
                componentRestrictions: { country: 'th' }
            };

            window.autocompleteService.getPlacePredictions(request, (predictions, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK && predictions) {
                    displaySearchResults(predictions);
                } else {
                    placeSearchResults.classList.add('hidden');
                }
            });
        }

        function displaySearchResults(predictions) {
            placeSearchResults.innerHTML = '';
            placeSearchResults.classList.remove('hidden');

            predictions.forEach(prediction => {
                const resultItem = document.createElement('div');
                resultItem.className = 'place-search-result-item';
                resultItem.innerHTML = `
                    <div class="place-name">${prediction.structured_formatting.main_text}</div>
                    <div class="place-address">${prediction.structured_formatting.secondary_text || ''}</div>
                `;

                resultItem.addEventListener('click', () => {
                    selectPlace(prediction);
                });

                placeSearchResults.appendChild(resultItem);
            });
        }

        function selectPlace(prediction) {
            const request = {
                placeId: prediction.place_id,
                fields: ['name', 'formatted_address', 'geometry', 'place_id']
            };

            window.placesService.getDetails(request, (place, status) => {
                if (status === google.maps.places.PlacesServiceStatus.OK) {
                    placeNameInput.value = place.name;
                    placeIdInput.value = place.place_id;
                    placeLatInput.value = place.geometry.location.lat();
                    placeLngInput.value = place.geometry.location.lng();
                    placeAddressInput.value = place.formatted_address;
                    placeSearchInput.value = place.name;
                    placeSearchResults.classList.add('hidden');
                    
                    showFeedbackBanner('✓ Google Place selected: ' + place.name);
                }
            });
        }

        function showFeedbackBanner(message) {
            const existingBanner = document.querySelector('.feedback-banner');
            if (existingBanner) {
                existingBanner.remove();
            }

            const banner = document.createElement('div');
            banner.className = 'feedback-banner';
            banner.textContent = message;
            
            form.insertBefore(banner, form.firstChild);

            setTimeout(() => {
                banner.style.opacity = '0';
                setTimeout(() => {
                    banner.remove();
                }, 300);
            }, 2700);
        }

        // Hide search results when clicking outside
        document.addEventListener('click', function(e) {
            if (!placeSearchInput.contains(e.target) && !placeSearchResults.contains(e.target)) {
                placeSearchResults.classList.add('hidden');
            }
        });

        // DRAG AND DROP FUNCTIONALITY
        let draggedElement = null;

        function addDragListeners(card) {
            card.addEventListener('dragstart', function(e) {
                draggedElement = this;
                this.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });

            card.addEventListener('dragend', function(e) {
                this.classList.remove('dragging');
                draggedElement = null;
            });
        }

        function addEditListener(card) {
            card.addEventListener('click', function(e) {
                if (this.classList.contains('dragging')) return;
                if (e.target.classList.contains('drag-handle')) return;

                editingCard = this;

                const strong = this.querySelector('strong').textContent;
                const timeSpan = this.querySelector('.time-span');
                const p = this.querySelector('p');
                const currentColumn = this.closest('.itinerary_column');
                const currentDate = currentColumn.dataset.date;

                // Pre-fill form
                form.title.value = strong;
                form.time.value = this.dataset.startTime || '';
                form.end_time.value = this.dataset.endTime || '';
                form.notes.value = p ? p.textContent : '';
                placeFormDate.value = currentDate;
                cardIdInput.value = this.dataset.cardId || '';

                // Pre-fill place data
                placeIdInput.value = this.dataset.placeId || '';
                placeLatInput.value = this.dataset.placeLat || '';
                placeLngInput.value = this.dataset.placeLng || '';
                placeAddressInput.value = this.dataset.placeAddress || '';
                
                if (this.dataset.placeId && this.dataset.originalPlaceName) {
                    placeSearchInput.value = this.dataset.originalPlaceName;
                } else if (this.dataset.placeId) {
                    placeSearchInput.value = strong;
                } else {
                    placeSearchInput.value = '';
                }

                // Update modal for edit mode
                document.querySelector('#placeCardForm h3').textContent = 'Edit Place';
                document.querySelector('#placeCardForm button[type="submit"]').textContent = 'Update Place';
                deleteBtn.style.display = 'inline-block';

                modal.classList.remove('hidden');
            });
        }

        // Add listeners to existing cards
        document.querySelectorAll('.place_card').forEach(card => {
            addDragListeners(card);
            addEditListener(card);
        });

        // Delete button functionality
        deleteBtn.addEventListener('click', async function() {
            if (editingCard && confirm('Are you sure you want to delete this place?')) {
                const cardId = editingCard.dataset.cardId;
                
                if (cardId) {
                    const success = await autoDeleteCard(cardId);
                    if (!success) {
                        return;
                    }
                }
                
                editingCard.remove();
                form.reset();
                clearGooglePlacesData();
                editingCard = null;
                modal.classList.add('hidden');
                
                // Update map markers if in map view
                if (viewToggle.checked) {
                    setTimeout(updateMapMarkers, 100);
                }
            }
        });

        // Auto-delete function
        async function autoDeleteCard(cardId) {
            showSaveStatus('saving', 'Deleting...');
            
            try {
                const response = await fetch(`/itinerary/${ITINERARY_ID}/place-cards/${cardId}/delete/`, {
                    method: 'DELETE',
                    headers: {
                        'X-CSRFToken': getCsrfToken()
                    }
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSaveStatus('saved', 'Deleted!');
                    return true;
                } else {
                    showSaveStatus('error', 'Delete failed');
                    console.error('Delete error:', result.message);
                    return false;
                }
            } catch (error) {
                showSaveStatus('error', 'Delete failed');
                console.error('Network error:', error);
                return false;
            }
        }

        // Make containers drop zones
        document.querySelectorAll('.place_cards_container').forEach(container => {
            container.addEventListener('dragover', function(e) {
                e.preventDefault();
                e.dataTransfer.dropEffect = 'move';
                
                const afterElement = getDragAfterElement(container, e.clientY);
                const dragging = document.querySelector('.dragging');
                
                if (afterElement == null) {
                    container.appendChild(dragging);
                } else {
                    container.insertBefore(dragging, afterElement);
                }
            });

            container.addEventListener('drop', async function(e) {
                e.preventDefault();
                
                if (draggedElement) {
                    draggedElement.classList.remove('dragging');
                    await saveCardOrderAfterDrop();
                }
            });
        });

        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.place_card:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        async function saveCardOrderAfterDrop() {
            const cardOrders = [];
            
            document.querySelectorAll('.itinerary_column').forEach(column => {
                const date = column.dataset.date;
                const cards = column.querySelectorAll('.place_card');
                
                cards.forEach((card, index) => {
                    const cardId = card.dataset.cardId;
                    if (cardId) {
                        cardOrders.push({
                            card_id: parseInt(cardId),
                            date: date,
                            order: index
                        });
                    }
                });
            });
            
            if (cardOrders.length > 0) {
                await autoSaveCardOrder(cardOrders);
            }
        }

        async function autoSaveCardOrder(cardOrders) {
            try {
                const response = await fetch(`/itinerary/${ITINERARY_ID}/place-cards/update-order/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'X-CSRFToken': getCsrfToken()
                    },
                    body: JSON.stringify({ card_orders: cardOrders })
                });
                
                const result = await response.json();
                
                if (result.success) {
                    showSaveStatus('saved', 'Order saved!');
                    
                    // Update map markers if in map view
                    if (viewToggle.checked) {
                        setTimeout(updateMapMarkers, 100);
                    }
                    
                    return true;
                } else {
                    console.error('Order save error:', result.message);
                    return false;
                }
            } catch (error) {
                console.error('Network error:', error);
                return false;
            }
        }
    });
</script>

<!-- Add CSRF token -->
<input type="hidden" name="csrfmiddlewaretoken" value="{{ csrf_token }}">

{% endblock %}